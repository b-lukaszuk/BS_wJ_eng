<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solution - Build SH*T with Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Build SH*T with Julia</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./mat_multip.html"><b>2</b> Matrix Multiplication</a></li>
<li><a class="menu-level-2" href="./mat_multip_problem.html"><b>2.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mat_multip_solution.html"><b>2.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bat_and_ball.html"><b>3</b> Bat and Ball</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_problem.html"><b>3.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_solution.html"><b>3.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./toothpaste.html"><b>4</b> Toothpaste</a></li>
<li><a class="menu-level-2" href="./toothpaste_problem.html"><b>4.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./toothpaste_solution.html"><b>4.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bile.html"><b>5</b> Bile</a></li>
<li><a class="menu-level-2" href="./bile_problem.html"><b>5.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bile_solution.html"><b>5.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./prime_numbers.html"><b>6</b> Prime Numbers</a></li>
<li><a class="menu-level-2" href="./prime_numbers_problem.html"><b>6.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./prime_numbers_solution.html"><b>6.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./logo.html"><b>7</b> Logo</a></li>
<li><a class="menu-level-2" href="./logo_problem.html"><b>7.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./logo_solution.html"><b>7.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./transcription.html"><b>8</b> Transcription</a></li>
<li><a class="menu-level-2" href="./transcription_problem.html"><b>8.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./transcription_solution.html"><b>8.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./translation.html"><b>9</b> Translation</a></li>
<li><a class="menu-level-2" href="./translation_problem.html"><b>9.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./translation_solution.html"><b>9.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./stem_and_leaf.html"><b>10</b> Stem and Leaf Plot</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>10.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_solution.html"><b>10.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./altruism.html"><b>11</b> Altruism</a></li>
<li><a class="menu-level-2" href="./altruism_problem.html"><b>11.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./altruism_solution.html"><b>11.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the-end.html"><b>12</b> The end</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="9.2" id="sec:translation_solution"><span class="header-section-number">9.2</span> Solution</h2>
<p>Let’s start as we did before by checking the file size.</p>
<pre class="language-julia"><code>#in &#39;code_snippets&#39; folder use &quot;./translation/mrna_seq.txt&quot;
#in &#39;transcription&#39; folder use &quot;./dna_seq_template_strand.txt&quot;
filePath = &quot;./code_snippets/translation/mrna_seq.txt&quot;
filesize(filePath)</code></pre>
<p>333</p>
<p>OK, it’s less than 1 KiB. Let’s read it and get a preview of the data.</p>
<pre class="language-julia"><code>mRna = open(filePath) do file
    read(file, Str)
end
mRna[1:60]</code></pre>
<p>auggcccuguggaugcgccuccugccccugcuggcgcugcuggcccucuggggaccugac</p>
<p>It looks good, no spaces between the letters, no newline (<code>\n</code>) characters (we removed them previously in Section <a href="./transcription_solution.html#sec:transcription_solution">8.2</a>).</p>
<p>The only issue with <code>mRna</code> is that <code>codon2aa</code> dictionary contains the codons (keys) in uppercase letters. All we need to do is to uppercase the letters in <code>mRna</code> using Julia’s function of the same name.</p>
<pre class="language-julia"><code>mRna = uppercase(mRna)
mRna[1:5]</code></pre>
<p>AUGGC</p>
<p>OK, time to start the translation. First let’s translate a triplet of nucleotide bases (aka codon) to an amino acid.</p>
<pre class="language-julia"><code># translates codon/triplet to amino acid IUPAC
function getAA(codon::Str)::Str
    @assert length(codon) == 3 &quot;codon must contain 3 nucleotide bases&quot;
    aaAbbrev::Str = get(codon2aa, codon, &quot;???&quot;)
    aaIUPAC::Str = get(aa2iupac, aaAbbrev, &quot;???&quot;)
    return aaIUPAC
end</code></pre>
<p>The function is rather simple. It accepts a codon (like <code>"AUG"</code>), next it translates a codon to an amino acid (abbreviated with 3 letters) using previously defined <code>codon2aa</code> dictionary. Then the 3-letter abbreviation is coded with a single letter recommended by IUPAC (using <code>aa2iupac</code> dictionary). If at any point no translation was found <code>"???"</code> is returned.</p>
<p>Now, time for translation.</p>
<pre class="language-julia"><code>function translate(mRnaSeq::Str)::Str
    len::Int = length(mRnaSeq)
    @assert len % 3 == 0 &quot;the number of bases must be multiple of 3&quot;
    aas::Vec{Str} = fill(&quot;&quot;, Int(len/3))
    aaInd::Int = 0
    for i in 1:3:len
        aaInd += 1
        codon::Str = mRnaSeq[i:(i+2)] # variable local to for loop
        aa::Str = getAA(codon) # variable local to for loop
        if aa == &quot;Stop&quot;
            break
        end
        aas[aaInd] = aa
    end
    return join(aas)
end</code></pre>
<p>We begin with some checks for the sequence. Then, we define the vector <code>aas</code> (<code>aas</code> - amino acids) holding our result. We initialize it with empty strings using <code>fill</code> function. We will assign the appropriate amino acids to <code>aas</code> based on the <code>aaInd</code> (<code>aaInd</code> - amino acid index) which we increase with every iteration (<code>aaInd += 1</code>). In <code>for</code> loop we iterate over each consecutive index with which a triple begins (<code>1:3:len</code> will return numbers as <code>[1, 4, 7, 10, 13, ...]</code>). Every consecutive <code>codon</code> (3 nucleotic bases) is obtained from <code>mRNASeq</code> using indexing by adding <code>+2</code> to the index that starts a triple (e.g. for i = 1, the three bases are at positions 1:3, for i = 4, those are 4:6, etc.). The <code>codon</code> is used to obtain the corresponding amino acid (<code>aa</code>) with <code>getAA</code>. If the <code>aa</code> is a so-called stop codon, then we immediately <code>break</code> free of the loop. Otherwise, we insert the <code>aa</code> to the appropriate place [<code>aaInd</code>] in <code>aas</code>. In the end we collapse the vector of strings into one long string with <code>join</code>. It is as if we used the string concatenation operator <code>*</code> on each element of <code>aas</code> like so <code>aas[1] * aas[2] * aas[3] * ...</code>. Notice, that e.g. <code>"A" * ""</code> or <code>"A" * "" * ""</code> is still <code>"A"</code>. This effectively gets rid of any empty <code>aas</code> elements that remained after reaching <code>aa == "Stop"</code> and <code>break</code> early.</p>
<p>Let’s see does it work.</p>
<pre class="language-julia"><code>protein = translate(mRna)
protein == expectedAAseq</code></pre>
<p>true</p>
<p>Congratulations! You have successfully synthesized pre-pro-insulin, a product transformed into a hormon that saved many a live. It could be only a matter of time before you achieve something greater still.</p>
<p>The above (<code>translate</code>) is not the only possible solution. For instance, if you are a fan of <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> paradigm you may try something like.</p>
<pre class="language-julia"><code>import Base.Iterators.takewhile as takewhile

function translate2(mRnaSeq::Str)::Str
    len::Int = length(mRnaSeq)
    @assert len % 3 == 0 &quot;the number of bases is not multiple of 3&quot;
    ranges::Vec{UnitRange{Int}} = map(:, 1:3:len, 3:3:len)
    codons::Vec{Str} = map(r -&gt; mRnaSeq[r], ranges)
    aas::Vec{Str} = map(getAA, codons)
    return takewhile(aa -&gt; aa != &quot;Stop&quot;, aas) |&gt; join
end</code></pre>
<p>We start by defining <code>ranges</code> that will help us get particular <code>codons</code> in the next step. For that purpose you take two sequences for start and end of a codon and glue them together with <code>:</code>. For instance <code>map(:, 1:3:9, 3:3:9)</code> roughly translates into <code>map(:, [1, 4, 7], [3, 6, 9])</code> which yields <code>[1:3, 4:6, 7:9]</code>, i.e. a vector of <code>UnitRange{Int}</code>. A <code>UnitRange{Int}</code> is a range composed of <code>Int</code>s separated by one unit, so by 1, like in <code>4:6</code> (<code>[4, 5, 6]</code> after expansion) mentioned above. Next, we map over those ranges and use each one of them (<code>r</code>) to get (<code>-&gt;</code>) a respective codon (<code>mRnaSeq[r]</code>). Then, we map over the <code>codons</code> to get respective amino acids (<code>getAA</code>). Finally, we move from left to right through the amiono acids (<code>aas</code>) vector and take its elements (<code>aa</code>) as long as they are not equal <code>"Stop"</code>. As the last step, we collapse the result with <code>join</code> to get one big string.</p>
<pre class="language-julia"><code>protein2 = translate2(mRna)
expectedAAseq == protein2</code></pre>
<p>true</p>
<p>Works as expected. The functional solution (<code>translate2</code>) often has fewer lines of code. It also consists of a series of consecutive logical steps, which is quite nice. However, for a beginner (or someone that doesn’t know this paradigm well) it appears more enigmatic (and therefore off-putting). Moreover, in general it is expected to be a bit slower than the more imperative for loop version (<code>translate</code>). This should be evident with long sequences [try <code>BenchmarkTools.@benchmark translate($mRna^20)</code> vs <code>@BenchmarkTools.@benchmark translate2($mRna^20)</code> in the REPL (type it after <code>julia&gt;</code> prompt)].</p>
<blockquote>
<p>Note. <code>$</code> (see above) is an interpolation of global variable recommended <a href="https://juliaci.github.io/BenchmarkTools.jl/stable/">by the package</a>. On the other hand, <code>^</code>, (again see above) replicates a string <code>n</code> times, e.g. <code>"ab" ^ 3</code> = <code>"ababab"</code>. Interestingly, although <code>translate(mRna^20)</code> and <code>translate2(mRna^20)</code> receive a strand of RNA 20 times longer than <code>mRna</code> they still return the same amino acid sequence as before. Test yourself and explain why. This will also help you realize why <code>translate2</code> is slower than its counterpart.</p>
</blockquote>
<p>In the said case (with <code>mRna^20</code>) the difference between <span class="math inline">\(\approx 27\ [\mu s]\)</span> and <span class="math inline">\(\approx 140\ [\mu s]\)</span> (on my laptop) shouldn’t be noticeable by a human (<span class="math inline">\(140\ [\mu s]\)</span> is a bit more than 1/10 th of a second). Therefore, if the performance is acceptable you may want to go with the functional version.</p>
<p>Anyway, both Section <a href="./transcription.html#sec:transcription">8</a> and Section <a href="./translation.html#sec:translation">9</a> were inspired by the lecture of <a href="https://www.researchgate.net/publication/16952023_Sequence_of_human_insulin_gene">this ResearchGate entry</a> based on which the DNA sequence was obtained (<code>dna_seq_template_strand.txt</code> from Section <a href="./transcription.html#sec:transcription">8</a>).</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./translation_problem.html"><b>9.1</b> Problem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./stem_and_leaf.html"><b>10</b> Stem and Leaf Plot</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>
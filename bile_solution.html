<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solution - Build SH*T with Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Build SH*T with Julia</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./mat_multip.html"><b>2</b> Matrix Multiplication</a></li>
<li><a class="menu-level-2" href="./mat_multip_problem.html"><b>2.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mat_multip_solution.html"><b>2.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bat_and_ball.html"><b>3</b> Bat and Ball</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_problem.html"><b>3.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_solution.html"><b>3.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./toothpaste.html"><b>4</b> Toothpaste</a></li>
<li><a class="menu-level-2" href="./toothpaste_problem.html"><b>4.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./toothpaste_solution.html"><b>4.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bile.html"><b>5</b> Bile</a></li>
<li><a class="menu-level-2" href="./bile_problem.html"><b>5.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bile_solution.html"><b>5.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./recursion.html"><b>6</b> Recursion</a></li>
<li><a class="menu-level-2" href="./recursion_problem.html"><b>6.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./recursion_solution.html"><b>6.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./prime_numbers.html"><b>7</b> Prime Numbers</a></li>
<li><a class="menu-level-2" href="./prime_numbers_problem.html"><b>7.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./prime_numbers_solution.html"><b>7.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./compound_interest.html"><b>8</b> Compound interest</a></li>
<li><a class="menu-level-2" href="./compound_interest_problem.html"><b>8.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./compound_interest_solution.html"><b>8.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./mortgage.html"><b>9</b> Mortgage</a></li>
<li><a class="menu-level-2" href="./mortgage_problem.html"><b>9.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mortgage_solution.html"><b>9.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./overpayment.html"><b>10</b> Overpayment</a></li>
<li><a class="menu-level-2" href="./overpayment_problem.html"><b>10.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./overpayment_solution.html"><b>10.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./logo.html"><b>11</b> Logo</a></li>
<li><a class="menu-level-2" href="./logo_problem.html"><b>11.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./logo_solution.html"><b>11.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./transcription.html"><b>12</b> Transcription</a></li>
<li><a class="menu-level-2" href="./transcription_problem.html"><b>12.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./transcription_solution.html"><b>12.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./translation.html"><b>13</b> Translation</a></li>
<li><a class="menu-level-2" href="./translation_problem.html"><b>13.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./translation_solution.html"><b>13.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./stem_and_leaf.html"><b>14</b> Stem and Leaf Plot</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>14.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_solution.html"><b>14.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./altruism.html"><b>15</b> Altruism</a></li>
<li><a class="menu-level-2" href="./altruism_problem.html"><b>15.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./altruism_solution.html"><b>15.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./shift.html"><b>16</b> Shift</a></li>
<li><a class="menu-level-2" href="./shift_problem.html"><b>16.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./shift_solution.html"><b>16.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./caesar.html"><b>17</b> Caesar</a></li>
<li><a class="menu-level-2" href="./caesar_problem.html"><b>17.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./caesar_solution.html"><b>17.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./vigenere.html"><b>18</b> Vigenere</a></li>
<li><a class="menu-level-2" href="./vigenere_problem.html"><b>18.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./vigenere_solution.html"><b>18.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the-end.html"><b>19</b> The end</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.2" id="sec:bile_solution"><span class="header-section-number">5.2</span> Solution</h2>
<p>To me the shape that resembles the droplet the most is <a href="https://en.wikipedia.org/wiki/Sphere">sphere</a>. Luckily, it also got well defined formulas for surface area and volume (see the link above), so this is what we will use in our solution.</p>
<pre class="language-julia"><code>struct Sphere
    radius::Flt
    Sphere(r::Flt) = r &lt;= 0 ? error(&quot;radius must be &gt; 0&quot;) : new(r)
end

# formula from Wikipedia
function getVolume(s::Sphere)::Flt
    return (4/3) * pi * s.radius^3
end

# formula from Wikipedia
function getSurfaceArea(s::Sphere)::Flt
    return 4 * pi * s.radius^2
end</code></pre>
<p>Now, let’s define a big lipid droplet with a radius of, let’s say, 10 [μm].</p>
<pre class="language-julia"><code>bigS = Sphere(10.0) # 10 um
bigV = getVolume(bigS)
bigA = getSurfaceArea(bigS)

bigV</code></pre>
<p>4188.790204786391</p>
<p>In the next step we will split this big droplet into a few smaller ones of equal sizes. Splitting the volume is easy, we just divide <code>bigV</code> by <code>n</code> droplets. However, we need a way to determine the size (<code>radius</code>) of each small droplet. Let’s try to transform the formula for a sphere’s volume and see if we can get radius from that.</p>
<p><span id="eq:sphere1"><span class="math display">\[ v = \frac{4}{3} * \pi * r^3 \qquad{(4)}\]</span></span></p>
<p>If a = b, then b = a, so we may swap sides.</p>
<p><span id="eq:sphere2"><span class="math display">\[ \frac{4}{3} * \pi * r^3 = v \qquad{(5)}\]</span></span></p>
<p>The multiplication is commutative (the order does not matter), i.e. 2 * 3 * 4 is the same as 4 * 3 * 2 or 2 * 4 * 3, therefore we can rearrange elements on the left side of Equation <a href="#eq:sphere2">5</a> to:</p>
<p><span id="eq:sphere3"><span class="math display">\[ r^3 * \frac{4}{3} * \pi = v \qquad{(6)}\]</span></span></p>
<p>Now, one by one we can move *<span class="math inline">\(\frac{4}{3}\)</span> and *<span class="math inline">\(\pi\)</span> to the right side of Equation <a href="#eq:sphere3">6</a>. Of course, we change the mathematical operation to the opposite (division instead of multiplication) and get:</p>
<p><span id="eq:sphere4"><span class="math display">\[ r^3 = v / \frac{4}{3} / \pi \qquad{(7)}\]</span></span></p>
<p>All that’s left to do is to move exponentiation (<span class="math inline">\(x^3\)</span>) to the right side of Equation <a href="#eq:sphere4">7</a> while changing it to the opposite mathematical operation (cube root, i.e. <span class="math inline">\(\sqrt[3]{x}\)</span>).</p>
<p><span id="eq:sphere5"><span class="math display">\[ r = \sqrt[3]{v / \frac{4}{3} / \pi} \qquad{(8)}\]</span></span></p>
<p>Now, you might wanted to quickly verify the solution using <code>Symbolic.symbolic_linear_solve</code> we met in Section <a href="./bat_and_ball_solution.html#sec:bat_and_ball_solution">3.2</a>. Unfortunately, we cannot use <code>r^3</code> (<code>r</code> to the 3rd power) as an argument (and solve for <code>r</code>), since then it wouldn’t be a linear equation (to be linear the maximum power must be equal to 1) required by <code>_linear_solve</code>. We could have used other, more complicated solver, but instead we will keep things simple and apply a little trick:</p>
<pre class="language-julia"><code>import Symbolics as Sym

# fraction - 4/3, p - π, r3 - r^3, v - volume
Sym.@variables fraction p r3 v
Sym.symbolic_linear_solve(fraction * p * r3 ~ v, r3)</code></pre>
<p>v / (fraction*p)</p>
<p>So, instead of writing the formula as it is, we just named our variables <code>fraction</code>, <code>p</code>, <code>r3</code> and <code>v</code>. Anyway, according to <code>Sym.symbolic_linear_solve</code> <span class="math inline">\(r^3 = v / (\frac{4}{3} * \pi)\)</span>, which is actually the same as Equation <a href="#eq:sphere4">7</a> above [since e.g. 18 / 2 / 3 == 18 / (2 * 3)]. Ergo, we may be fairly certain we correctly solved Equation <a href="#eq:sphere4">7</a> and therefore Equation <a href="#eq:sphere5">8</a>.</p>
<p>Once, we confimed the validity of the formula in Equation <a href="#eq:sphere5">8</a>, all that’s left to do is to translate it into Julia code.</p>
<pre class="language-julia"><code>function getSphere(volume::Flt)::Sphere
    # cbrt - fn that calculates cube root of a number
    radius::Flt = cbrt(volume / (4/3) / pi)
    return Sphere(radius)
end</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> If there were no function for <span class="math inline">\(\sqrt[3]{x}\)</span> you could easily define it yourself with: <code>getCbrt(x) = x^(1/3)</code> (here I used a <a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions#Single_expression_functions">single expression function</a> for brevity) since <span class="math inline">\(\sqrt[n]{x} = x^{1/n}\)</span>.</p>
</blockquote>
<p>Time to test how it works. Let’s see if we can divide <code>bigS</code> (actually its volume: <code>bigV</code>) into 4 smaller drops of total volume equal to <code>bigV</code>.</p>
<pre class="language-julia"><code># isapprox compares variables for equality
# accounts for possible rounding error
isapprox(
    getSphere(bigV / 4) |&gt; getVolume,
    bigV / 4
)</code></pre>
<p>true</p>
<p>Once we got that working, we evaluate the total area of the droplets of different size.</p>
<pre class="language-julia"><code>sumsOfAreas = [bigA]
sumsOfVolumes = [bigV]
radii = [bigS.radius]

numsOfDroplets = collect(4:4:12)
for nDrops in numsOfDroplets
    # local variables smallS, smallV, smallA, sumSmallAs, sumSmallVs
    # visible only in for loop
    smallS = getSphere(bigV / nDrops)
    smallV = getVolume(smallS)
    smallA = getSurfaceArea(smallS)
    sumSmallAs = smallA * nDrops
    sumSmallVs = smallV * nDrops
    push!(sumsOfAreas, sumSmallAs)
    push!(sumsOfVolumes, sumSmallVs)
    push!(radii, smallS.radius)
end

prepend!(numsOfDroplets, 1)</code></pre>
<p>We begin by initializing vectors that will hold the <code>sumsOfAreas</code>, <code>sumsOfvolumes</code>, and <code>radii</code> of our lipid droplets. Then we define the number of droplets that we want to split our big droplet into (<code>numsOfDroplets</code>). For each of those (<code>for nDrops in numsOfDroplets</code>) we determine the radius (<code>smallS = getSphere</code>), volume (<code>smallV</code>) and surface area (<code>smallA</code>) of a single small droplet as well as total area (<code>sumSmallAs</code>) and total volume (<code>sumSmallVs</code>) of <code>nDrops</code>. We add the total area, total volume and radius of a single droplet to the <code>sumsOfAreas</code>, <code>sumsOfVolumes</code>, and <code>radii</code> vectors, respectively. In the end we <code>prepend</code> 1 to the <code>numOfDroplets</code>, since we started with one big droplet (<code>bigS</code>).</p>
<p>BTW. Notice that <code>smallS</code>, <code>smallV</code>, <code>smallA</code>, <code>sumSmallAs</code>, <code>sumSmallVs</code> are all local variables defined for the first time in the <code>for</code> loop and visible only inside of it. If you try to print out their values outside of the loop you will get an error like <code>ERROR: UndefVarError: 'smallS' not defined</code>.</p>
<p>Anyway, now, we can either examine the vectors (<code>sumsOfAreas</code>, <code>sumsOfVolumes</code>, <code>radii</code>, <code>numOfDroplets</code>) one by one, or do one better and present them on a graph with e.g. CairoMakie (I’m not going to explain the code below, for reference see <a href="https://b-lukaszuk.github.io/RJ_BS_eng/">my previous book</a> or <a href="https://docs.makie.org/stable/tutorials/getting-started">CairoMakie tutorial</a>).</p>
<pre><code>import CairoMakie as Cmk

fig = Cmk.Figure();
ax = Cmk.Axis(fig[1, 1],
              title=&quot;Lipid droplet size vs. summaric surface area&quot;,
              xlabel=&quot;number of lipid droplets&quot;,
              ylabel=&quot;total surface area [μm²]&quot;, xticks=0:13);
Cmk.scatter!(ax, numsOfDroplets, sumsOfAreas, markersize=radii .* 5,
             color=&quot;gold1&quot;, strokecolor=&quot;black&quot;);
Cmk.xlims!(ax, -3, 16);
Cmk.ylims!(ax, 800, 3000);
Cmk.text!(ax, numsOfDroplets, sumsOfAreas .- 150,
    text=map(r -&gt; &quot;single droplet radius = $(round(r, digits=2)) [μm]&quot;,
             radii),
    fontsize=12, align=(:center, :center)
);
Cmk.text!(ax, numsOfDroplets, sumsOfAreas .- 250,
    text=map((v, n) -&gt;
    &quot;volume ($n droplet/s) = $(round(v, digits=2)) [μm³]&quot;,
    sumsOfVolumes, numsOfDroplets),
    fontsize=12, align=(:center, :center)
);
fig</code></pre>
<p>Behold.</p>
<figure id="fig:bile">
<img src="./images/bile.png" alt="Figure 1: Bile. Splitting a big lipid droplet into a few smaller ones and the effect it has on their total surface area." />
<figcaption aria-hidden="true">Figure 1: Bile. Splitting a big lipid droplet into a few smaller ones and the effect it has on their total surface area.</figcaption>
</figure>
<p>So it turns out that what they taught me in the school all those years ago is actually true. But only now I can finally see it. Nice.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./bile_problem.html"><b>5.1</b> Problem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./recursion.html"><b>6</b> Recursion</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>
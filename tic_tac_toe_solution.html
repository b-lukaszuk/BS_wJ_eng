<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solution - Build SH*T with Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Build SH*T with Julia</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./mat_multip.html"><b>2</b> Matrix Multiplication</a></li>
<li><a class="menu-level-2" href="./mat_multip_problem.html"><b>2.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mat_multip_solution.html"><b>2.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bat_and_ball.html"><b>3</b> Bat and Ball</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_problem.html"><b>3.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_solution.html"><b>3.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./camel_case.html"><b>4</b> Camel case</a></li>
<li><a class="menu-level-2" href="./camel_case_problem.html"><b>4.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./camel_case_solution.html"><b>4.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./toothpaste.html"><b>5</b> Toothpaste</a></li>
<li><a class="menu-level-2" href="./toothpaste_problem.html"><b>5.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./toothpaste_solution.html"><b>5.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bile.html"><b>6</b> Bile</a></li>
<li><a class="menu-level-2" href="./bile_problem.html"><b>6.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bile_solution.html"><b>6.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./recursion.html"><b>7</b> Recursion</a></li>
<li><a class="menu-level-2" href="./recursion_problem.html"><b>7.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./recursion_solution.html"><b>7.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./progress_bar.html"><b>8</b> Progress Bar</a></li>
<li><a class="menu-level-2" href="./progress_bar_problem.html"><b>8.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./progress_bar_solution.html"><b>8.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./pascals_triangle.html"><b>9</b> Pascal’s triangle</a></li>
<li><a class="menu-level-2" href="./pascals_triangle_problem.html"><b>9.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./pascals_triangle_solution.html"><b>9.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./tree.html"><b>10</b> Tree</a></li>
<li><a class="menu-level-2" href="./tree_problem.html"><b>10.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./tree_solution.html"><b>10.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./roman_numerals.html"><b>11</b> Roman numerals</a></li>
<li><a class="menu-level-2" href="./roman_numerals_problem.html"><b>11.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./roman_numerals_solution.html"><b>11.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./cheque.html"><b>12</b> Cheque</a></li>
<li><a class="menu-level-2" href="./cheque_problem.html"><b>12.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./cheque_solution.html"><b>12.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./binary.html"><b>13</b> Binary</a></li>
<li><a class="menu-level-2" href="./binary_problem.html"><b>13.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./binary_solution.html"><b>13.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./leap_year.html"><b>14</b> Leap year</a></li>
<li><a class="menu-level-2" href="./leap_year_problem.html"><b>14.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./leap_year_solution.html"><b>14.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./calendar.html"><b>15</b> Calendar</a></li>
<li><a class="menu-level-2" href="./calendar_problem.html"><b>15.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./calendar_solution.html"><b>15.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./prime_numbers.html"><b>16</b> Prime Numbers</a></li>
<li><a class="menu-level-2" href="./prime_numbers_problem.html"><b>16.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./prime_numbers_solution.html"><b>16.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./tic_tac_toe.html"><b>17</b> Tic-tac-toe</a></li>
<li><a class="menu-level-2" href="./tic_tac_toe_problem.html"><b>17.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./tic_tac_toe_solution.html"><b>17.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./compound_interest.html"><b>18</b> Compound interest</a></li>
<li><a class="menu-level-2" href="./compound_interest_problem.html"><b>18.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./compound_interest_solution.html"><b>18.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./mortgage.html"><b>19</b> Mortgage</a></li>
<li><a class="menu-level-2" href="./mortgage_problem.html"><b>19.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mortgage_solution.html"><b>19.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./overpayment.html"><b>20</b> Overpayment</a></li>
<li><a class="menu-level-2" href="./overpayment_problem.html"><b>20.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./overpayment_solution.html"><b>20.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./logo.html"><b>21</b> Logo</a></li>
<li><a class="menu-level-2" href="./logo_problem.html"><b>21.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./logo_solution.html"><b>21.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./transcription.html"><b>22</b> Transcription</a></li>
<li><a class="menu-level-2" href="./transcription_problem.html"><b>22.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./transcription_solution.html"><b>22.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./translation.html"><b>23</b> Translation</a></li>
<li><a class="menu-level-2" href="./translation_problem.html"><b>23.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./translation_solution.html"><b>23.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./stem_and_leaf.html"><b>24</b> Stem and Leaf Plot</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>24.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_solution.html"><b>24.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./altruism.html"><b>25</b> Altruism</a></li>
<li><a class="menu-level-2" href="./altruism_problem.html"><b>25.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./altruism_solution.html"><b>25.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./shift.html"><b>26</b> Shift</a></li>
<li><a class="menu-level-2" href="./shift_problem.html"><b>26.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./shift_solution.html"><b>26.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./caesar.html"><b>27</b> Caesar</a></li>
<li><a class="menu-level-2" href="./caesar_problem.html"><b>27.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./caesar_solution.html"><b>27.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./vigenere.html"><b>28</b> Vigenere</a></li>
<li><a class="menu-level-2" href="./vigenere_problem.html"><b>28.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./vigenere_solution.html"><b>28.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the-end.html"><b>29</b> The end</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="17.2" id="sec:tic_tac_toe_solution"><span class="header-section-number">17.2</span> Solution</h2>
<p>The first decision we must make is the internal representation of our game board. Two candidate data types come to mind right away, a vector or a matrix. Here, I’ll go with the first option.</p>
<pre class="language-julia"><code>function getNewGameBoard()::Vec{Str}
    return string.(1:9)
end</code></pre>
<p>Next, we’ll define a few constants that will be helpful later on.</p>
<pre class="language-julia"><code>const PLAYERS = [&quot;X&quot;, &quot;O&quot;]
# LINES[1:3] - rows, LINES[4:6] - columns, LINES[7:8] - diagonals
const LINES= [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [1, 4, 7],
    [2, 5, 8],
    [3, 6, 9],
    [1, 5, 9],
    [3, 5, 7]
]</code></pre>
<blockquote>
<p>Note. Using <code>const</code> with mutable containers like vectors or dictionaries allows to change their contents in the future, e.g., with <code>push!</code>. So the <code>const</code> used here is more like a convention, a signal that we do not plan to change the containers in the future. If we really wanted an immutable container then we should consider a(n) (immutable) tuple. Anyway, some programming languages suggest that <code>const</code> names should be declared using all uppercase characters to make them stand out. Here, I follow this convention.</p>
</blockquote>
<p>The two are: <code>PLAYERS</code>, a vector with marks used by each of the players (<code>"X"</code> - human, <code>"O"</code> - computer) and the coordinates of <code>LINES</code> in our game board that we need to check to see if a player won the game. You could probably be more clever and use <a href="https://docs.julialang.org/en/v1/base/base/#Base.Enums.Enum">enums</a> for the players and list comprehensions for our lines (e.g., <code>[collect(i:(i+2)) for i in [1, 4, 7]]</code> to get the rows), but for such a simple case it might be overkill.</p>
<p>OK, time to format the board.</p>
<pre class="language-julia"><code># https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
function getGray(s::Str)::Str
    # &quot;\x1b[90m&quot; sets forground color to gray
    # &quot;\x1b[0m&quot; resets forground color to default value
    return &quot;\x1b[90m&quot; * s * &quot;\x1b[0m&quot;
end

function isFree2Take(field::Str)::Bool
    return !(field in PLAYERS)
end

function colorFieldNumbers(board::Vec{Str})::Vec{Str}
    result::Vec{Str} = copy(board)
    for i in eachindex(board)
        if isFree2Take(board[i])
            result[i] = getGray(board[i])
        end
    end
    return result
end</code></pre>
<p>We begin with the definition of <code>getGray</code> that will change the font color of the selected symbols from our game board. This should look nice on a standard, dark terminal display. Still, feel free to adjust the color to your needs (although if you use a terminal with a white background you may rather stop and get some help). Anyway, a field not taken by one of the players (<code>isFree2Take</code>) will be colored by <code>colorFieldNumbers</code>.</p>
<p>Personally, I would also opt to add the function for the triplets detection (<code>isTriplet</code>). which we will use to color them (first one we find based on <code>LINES</code>) with <code>colorFirstTriplet</code>. This should allow us for easier visual determination when the game is over (later on we will also use it in <code>isGameWon</code>).</p>
<pre class="language-julia"><code># https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
function getRed(s::Str)::Str
    # &quot;\x1b[31m&quot; sets forground color to red
    # &quot;\x1b[0m&quot; resets forground color to default value
    return &quot;\x1b[31m&quot; * s * &quot;\x1b[0m&quot;
end

function isTriplet(v::Vec{Str})::Bool
    @assert length(v) == 3 &quot;length(v) must be equal 3&quot;
    return join(v) == &quot;XXX&quot; || join(v) == &quot;OOO&quot;
end

function colorFirstTriplet(board::Vec{Str})::Vec{Str}
    result::Vec{Str} = copy(board)
    for line in LINES
        if isTriplet(board[line])
            result[line] = getRed.(result[line])
            return result
        end
    end
    return result
end</code></pre>
<p>Notice, that neither <code>colorFieldNumbers</code>, nor <code>colorFirstTriplet</code> modify the original game board, instead they produce a copy of it which is returned as a result (since the game board is a short vector there shouldn’t be any serious performance issues).</p>
<p>Now, we are ready to print.</p>
<pre class="language-julia"><code># https://en.wikipedia.org/wiki/ANSI_escape_code
function clearLines(nLines::Int)
    @assert 0 &lt; nLines &quot;nLines must be a positive integer&quot;
    # &quot;\033[xxxA&quot; - xxx moves cursor up xxx LINES
    print(&quot;\033[&quot;, nLines, &quot;A&quot;)
    # &quot;\033[0J&quot; - clears from cursor position till the end of the screen
    print(&quot;\033[0J&quot;)
    return nothing
end

function printBoard(board::Vec{Str})
    bd::Vec{Str} = colorFieldNumbers(board)
    bd = colorFirstTriplet(bd)
    for row in LINES[1:3] # first 3 LINES are for rows
        println(&quot; &quot;, join(bd[row], &quot; | &quot;))
        println(&quot;---+---+---&quot;)
    end
    clearLines(1)
    return nothing
end</code></pre>
<p>First, we declare <code>clearLines</code>, it will help us to tidy the printout (e.g., while playing the game we will have to redraw the game board a couple of times). Next, we proceed with <code>printBoard</code>. We color the board with the previously defined functions and move row by row (<code>LINES[1:3]</code> contains the indices for the three rows). We <code>join</code> the contents of a row together (we glue them with <code>" | "</code>) and print it (<code>println</code>). We follow it by a row separator (<code>println("---+---+---")</code>). Once we’re finished we remove the last row separator with <code>clearLines(1)</code> (we do not want it, but it was printed because we were too lazy to add an if statement in our for loop).</p>
<p>So far, so good, time to handle a human player’s (aka user’s) move.</p>
<pre class="language-julia"><code>function getUserInput(prompt::Str)::Str
    print(prompt)
    input::Str = readline()
    return strip(input)
end

function isMoveLegal(move::Str, board::Vec{Str})::Bool
    num::Int = 0
    try
        num = parse(Int, move)
    catch
        return false
    end
    return (num in eachindex(board)) &amp;&amp; isFree2Take(board[num])
end

function getUserMove(gameBoard::Vec{Str})::Int
    input::Str = getUserInput(&quot;Enter your move: &quot;)
    while !isMoveLegal(input, gameBoard)
        clearLines(1)
        input = getUserInput(&quot;Illegal move. Try again. Enter your move: &quot;)
    end
    return parse(Int, input)
end</code></pre>
<blockquote>
<p>Note. Using <code>while</code> loop always carries a risk of it being infinite, that’s why it is worth to know that you can always press <a href="https://en.wikipedia.org/wiki/Control-C">Ctrl+C</a> that should terminate the program execution.</p>
</blockquote>
<p>We begin with <code>getUserInput</code> a function that takes the <code>prompt</code> (its argument, it tells the user what to do), prints it, and accepts the user’s input (<code>readline</code>) that is returned as a result (after <code>strip</code>ing it from space/tab/new line characters that may be on the edges).</p>
<p>Next, we make sure that the move made by the user is legal (<code>isMoveLegal</code>), i.e. it can be correctly converted to an integer (<code>parse(Int, move)</code>), it is in the acceptable range (<code>num in eachindex(board)</code>) and is the field free to place the player’s mark (<code>isFree2Take(board[num])</code>). Notice, the use of <code>try</code> and <code>catch</code> construct. First we <code>try</code> to make an integer out of the string obtained from the user (<code>parse(Int, move)</code>). This may fail (e.g., because we got the letter <code>"a"</code> instead of the number <code>"2"</code>). Such a failure, will result in an error that would normally terminate the program execution. We don’t want that to happen, so we <code>catch</code> a possible error and instead of terminating the program, we just <code>return false</code>. If the <code>try</code> succeeds, we skip the <code>catch</code> part and go straight to the next statement after the <code>try</code>-<code>catch</code> block (<code>return (num in eachindex(board)) &amp;&amp; isFree2Take(board[num])</code>) that we already discussed.</p>
<p>Finally, we declare <code>getUserMove</code>, a function that asks the user for a move and is quite persistent about it. If the user gives a correct move the first time (<code>input::Str = getUserInput("Enter your move: ")</code>) then the while loop condition (<code>!isMoveLegal(input, gameBoard)</code>) is false and the loop isn’t executed at all (we move to the return statement). However, if the user plays tricks on us and wants to smuggle an illegal move (or maybe they just did it absent-mindedly) then the condition (<code>!isMoveLegal(input, gameBoard)</code>) is true and <code>while</code> it is we nag the user for a correct move (<code>"Illegal move. Try again. Enter your move: "</code>).</p>
<p>OK, and how about a computer move.</p>
<pre class="language-julia"><code>function getComputerMove(board::Vec{Str})::Int
    move::Int = 0
    for i in eachindex(board)
        if isFree2Take(board[i])
            move = i
            break
        end
    end
    println(&quot;Computer plays: &quot;, move)
    return move
end</code></pre>
<p>We start small, <code>getComputerMove</code> will simply walk through the board and return an index (<code>i</code>) of a first empty, i.e., not taken by a player (<code>isFree2Take(board[i])</code>) field. If all the fields are taken it will return <code>0</code> (in reality this will never happen as we will see in <code>playGame</code> later on). Since <code>getUserMove</code> prints one line of a screen output, then so does <code>getComputerMove</code> (<code>println("Computer plays: ", move)</code>) for compatibility.</p>
<p>Time to actually make a move that we obtained for a player.</p>
<pre class="language-julia"><code>function makeMove!(move::Int, player::Str, board::Vec{Str})
    @assert move in eachindex(board) &quot;move must be in range [1-9]&quot;
    @assert player in PLAYERS &quot;player must be X or O&quot;
    if isFree2Take(board[move])
        board[move] = player
    end
    return nothing
end</code></pre>
<p>For that we just take the <code>move</code>, a <code>player</code> for whom we place the mark, and the game <code>board</code> that we will modify. If a given field isn’t taken (or to put it differently, it’s free to take, hence <code>if isFree2Take(board[move])</code>) we just put the mark for a player there (<code>board[move] = player</code>).</p>
<p>Time to write <code>playMove</code>, a function that will handle a player, their move and its display on the screen.</p>
<pre class="language-julia"><code>function playMove!(player::Str, board::Vec{Str})
    @assert player in PLAYERS &quot;player must be X or O&quot;
    printBoard(board)
    move::Int = (player==&quot;X&quot;) ? getUserMove(board) : getComputerMove(board)
    makeMove!(move, player, board)
    clearLines(6)
    printBoard(board)
    return nothing
end</code></pre>
<p>We begin by displaying the board (<code>printBoard</code>) and obtaining a <code>move</code> for a player (<code>(player == "X") ? getUserMove(board) : getComputerMove(board)</code>). Once we got the move, we place the correct marker on the board (with <code>makeMove!</code>) and re-draw the board (<code>clearLines</code> and <code>printBoard</code>).</p>
<p>Now, we are almost ready to actually play a game. Almost, because we need a few more helper functions. First, we must figure out when the game is over and why. This can be simply achieved with the following snippet.</p>
<pre class="language-julia"><code>function isGameWon(board::Vec{Str})::Bool
    for line in LINES
        if isTriplet(board[line])
            return true
        end
    end
    return false
end

function isNoMoreMoves(board::Vec{Str})::Bool
    for i in eachindex(board)
        if isFree2Take(board[i])
            return false
        end
    end
    return true
end

function isGameOver(board::Vec{Str})::Bool
    return isGameWon(board) || isNoMoreMoves(board)
end</code></pre>
<p>Once the game is over we display an appropriate info.</p>
<pre class="language-julia"><code>function displayGameOverScreen(player::Str, board::Vec{Str})
    @assert player in PLAYERS &quot;player must be X or O&quot;
    printBoard(board)
    print(&quot;Game Over. &quot;)
    isGameWon(board) ?
        println(player == &quot;X&quot; ? &quot;You&quot; : &quot;Computer&quot;, &quot; won.&quot;) :
        println(&quot;Draw.&quot;)
    return nothing
end</code></pre>
<p>And finally, we’re ready to play the game.</p>
<pre class="language-julia"><code>function togglePlayer(player::Str)::Str
    @assert player in PLAYERS &quot;player must be X or O&quot;
    return player == &quot;X&quot; ? &quot;O&quot; : &quot;X&quot;
end

function playGame()
    board::Vec{Str} = getNewGameBoard()
    player::Str = &quot;O&quot;
    while !isGameOver(board)
        player = togglePlayer(player)
        playMove!(player, board)
        clearLines(5)
    end
    displayGameOverScreen(player, board)
    return nothing
end</code></pre>
<p>Inside <code>playGame</code> we initialize <code>board</code> and the <code>player</code> on a move. Next, while the game isn’t over (<code>while !isGameOver(board)</code>), we toggle the player (<code>togglePlayer(player)</code>), <code>playMove</code> and clear the display (<code>clearLines(5)</code>) before another move. When the game is finished we just <code>displayGameOverScreen</code>. And voila. You can <code>playGame</code>. Test it, e.g., with the following sequence of moves: 2, 3, 7, 6, 9 - you win; 2, 3, 6, 8 - computer wins; 7, 2, 4, 6, 9 - draw.</p>
<p>There are a couple of things to improve on (if you want to). For instance, you could add a <code>sleep</code> statement into <code>getComputerMove</code> so that the user got time to read the message with move declaration (<code>println("Computer plays: ", move)</code>). Moreover, as for now the algorithm generating move in <code>getComputerMove</code> is great for testing, but gets boring pretty quickly, feel free to change it (or try to beat a somewhat more challenging algorithm found in <a href="https://github.com/b-lukaszuk/BS_wJ_eng/tree/main/code_snippets/tic_tac_toe">the code snippets</a>).</p>
<p>Lastly, like in Section <a href="./progress_bar_solution.html#sec:progress_bar_solution">8.2</a> you could also add the functionality to run the game from a terminal (with <code>julia tic_tac_toe.jl</code>).</p>
<pre class="language-julia"><code>function main()
    println(&quot;This is a toy program to play a tic-tac-toe game.&quot;)
    println(&quot;Note: your terminal must support ANSI escape codes.\n&quot;)

    # y(es) - default choice (also with Enter), anything else: no
    println(&quot;Continue with the game? [Y/n]&quot;)
    choice::Str = readline()
    if lowercase(strip(choice)) in [&quot;y&quot;, &quot;yes&quot;, &quot;&quot;]
        playGame()
    end

    println(&quot;\nThat&#39;s all. Goodbye!&quot;)
end

if abspath(PROGRAM_FILE) == @__FILE__
    main()
end</code></pre>
<p>That’s it. Have fun playing the game.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./tic_tac_toe_problem.html"><b>17.1</b> Problem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./compound_interest.html"><b>18</b> Compound interest</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>
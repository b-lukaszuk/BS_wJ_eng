<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solution - Build SH*T with Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Build SH*T with Julia</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./mat_multip.html"><b>2</b> Matrix Multiplication</a></li>
<li><a class="menu-level-2" href="./mat_multip_problem.html"><b>2.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mat_multip_solution.html"><b>2.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bat_and_ball.html"><b>3</b> Bat and Ball</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_problem.html"><b>3.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_solution.html"><b>3.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./camel_case.html"><b>4</b> Camel case</a></li>
<li><a class="menu-level-2" href="./camel_case_problem.html"><b>4.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./camel_case_solution.html"><b>4.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./toothpaste.html"><b>5</b> Toothpaste</a></li>
<li><a class="menu-level-2" href="./toothpaste_problem.html"><b>5.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./toothpaste_solution.html"><b>5.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bile.html"><b>6</b> Bile</a></li>
<li><a class="menu-level-2" href="./bile_problem.html"><b>6.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bile_solution.html"><b>6.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./recursion.html"><b>7</b> Recursion</a></li>
<li><a class="menu-level-2" href="./recursion_problem.html"><b>7.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./recursion_solution.html"><b>7.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./progress_bar.html"><b>8</b> Progress Bar</a></li>
<li><a class="menu-level-2" href="./progress_bar_problem.html"><b>8.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./progress_bar_solution.html"><b>8.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./pascals_triangle.html"><b>9</b> Pascal’s triangle</a></li>
<li><a class="menu-level-2" href="./pascals_triangle_problem.html"><b>9.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./pascals_triangle_solution.html"><b>9.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./tree.html"><b>10</b> Tree</a></li>
<li><a class="menu-level-2" href="./tree_problem.html"><b>10.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./tree_solution.html"><b>10.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./roman_numerals.html"><b>11</b> Roman numerals</a></li>
<li><a class="menu-level-2" href="./roman_numerals_problem.html"><b>11.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./roman_numerals_solution.html"><b>11.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./cheque.html"><b>12</b> Cheque</a></li>
<li><a class="menu-level-2" href="./cheque_problem.html"><b>12.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./cheque_solution.html"><b>12.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./binary.html"><b>13</b> Binary</a></li>
<li><a class="menu-level-2" href="./binary_problem.html"><b>13.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./binary_solution.html"><b>13.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./leap_year.html"><b>14</b> Leap year</a></li>
<li><a class="menu-level-2" href="./leap_year_problem.html"><b>14.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./leap_year_solution.html"><b>14.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./calendar.html"><b>15</b> Calendar</a></li>
<li><a class="menu-level-2" href="./calendar_problem.html"><b>15.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./calendar_solution.html"><b>15.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./prime_numbers.html"><b>16</b> Prime Numbers</a></li>
<li><a class="menu-level-2" href="./prime_numbers_problem.html"><b>16.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./prime_numbers_solution.html"><b>16.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./tic_tac_toe.html"><b>17</b> Tic-tac-toe</a></li>
<li><a class="menu-level-2" href="./tic_tac_toe_problem.html"><b>17.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./tic_tac_toe_solution.html"><b>17.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./compound_interest.html"><b>18</b> Compound interest</a></li>
<li><a class="menu-level-2" href="./compound_interest_problem.html"><b>18.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./compound_interest_solution.html"><b>18.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./mortgage.html"><b>19</b> Mortgage</a></li>
<li><a class="menu-level-2" href="./mortgage_problem.html"><b>19.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mortgage_solution.html"><b>19.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./overpayment.html"><b>20</b> Overpayment</a></li>
<li><a class="menu-level-2" href="./overpayment_problem.html"><b>20.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./overpayment_solution.html"><b>20.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./logo.html"><b>21</b> Logo</a></li>
<li><a class="menu-level-2" href="./logo_problem.html"><b>21.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./logo_solution.html"><b>21.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./transcription.html"><b>22</b> Transcription</a></li>
<li><a class="menu-level-2" href="./transcription_problem.html"><b>22.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./transcription_solution.html"><b>22.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./translation.html"><b>23</b> Translation</a></li>
<li><a class="menu-level-2" href="./translation_problem.html"><b>23.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./translation_solution.html"><b>23.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./stem_and_leaf.html"><b>24</b> Stem and Leaf Plot</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>24.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_solution.html"><b>24.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./altruism.html"><b>25</b> Altruism</a></li>
<li><a class="menu-level-2" href="./altruism_problem.html"><b>25.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./altruism_solution.html"><b>25.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./shift.html"><b>26</b> Shift</a></li>
<li><a class="menu-level-2" href="./shift_problem.html"><b>26.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./shift_solution.html"><b>26.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./caesar.html"><b>27</b> Caesar</a></li>
<li><a class="menu-level-2" href="./caesar_problem.html"><b>27.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./caesar_solution.html"><b>27.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./vigenere.html"><b>28</b> Vigenere</a></li>
<li><a class="menu-level-2" href="./vigenere_problem.html"><b>28.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./vigenere_solution.html"><b>28.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the-end.html"><b>29</b> The end</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="13.2" id="sec:binary_solution"><span class="header-section-number">13.2</span> Solution</h2>
<p>Let’s start with our <code>dec2bin</code> converter, we’ll base it on the <a href="https://www.youtube.com/watch?v=ku4KOFQ-bB4&amp;list=PLS---sZ5WJJvsjaAQZKwTwxl910xUdO98">Khan Academy videos</a> and similarities with the decimal number system.</p>
<p><a href="https://en.wikipedia.org/wiki/Decimal">The decimal system</a> operates on base 10. A number, let’s say: one hundred and twenty-three (123), can be written with digits ([0-9]) placed in three slots. We know this because three slots allow us to write <span class="math inline">\(10^3 = 1000\)</span> numbers ([0-999]), whereas two slots are good only for <span class="math inline">\(10^2 = 100\)</span> numbers ([0-99], compare also with the <a href="https://b-lukaszuk.github.io/RJ_BS_eng/statistics_intro_exercises.html#sec:statistics_intro_exercise1">exercise 1</a> and <a href="https://b-lukaszuk.github.io/RJ_BS_eng/statistics_intro_exercises_solutions.html#sec:statistics_intro_exercise1_solution">its solution</a>). The number 123 is actually a sum of one hundred, two tens, and three units (<span class="math inline">\(1*100 + 2*10 + 3*1\)</span> = <code>sum([1*100, 2*10, 3*1])</code> = 123). Equivalently, this can be written with the consecutive powers of ten (<span class="math inline">\(10^x\)</span> = <code>10^x</code> in Julia’s code, where x starts from the right and at 0), i.e. <span class="math inline">\(1*10^2 + 2*10^1 + 3*10^0\)</span> = <code>sum([1*10^2, 2*10^1, 3*10^0])</code> = 123. Pause for a moment and make sure you got that.</p>
<p>Similar reasoning applies to binary numbers, but here we operate on the powers of two. A decimal number, let’s say: fourteen (14), can be written with digits ([0-1]) placed in four slots. This is because <span class="math inline">\(2^4\)</span> allows us to write down 16 numbers (in binary: [0000-1111], in decimal: [0-15]), whereas <span class="math inline">\(2^3\)</span> suffices only for 8 numbers (in binary: [000-111], in decimal: [0-7]). Each slot (from right to left) represents subsequent powers of two, i.e. ones (<span class="math inline">\(2^0 = 1\)</span>), twos (<span class="math inline">\(2^1 = 2\)</span>), fours (<span class="math inline">\(2^2 = 4\)</span>), and eights (<span class="math inline">\(2^3 = 8\)</span>). Once again we sum the digits to get our encoded number <code>1110</code> = <span class="math inline">\(1*2^3 + 1*2^2 + 1*2^1 + 1*2^0\)</span> = <span class="math inline">\(1*8 + 1*4 + 1*2 + 1*0\)</span> = <code>sum([1*8, 1*4, 1*2, 1*0])</code> = 14. Time to put that knowledge to good use by writing our <code>dec2bin</code>.</p>
<pre class="language-julia"><code>function getNumOfBits2codeDec(dec::Int)::Int
    @assert 0 &lt;= dec &lt;= 1024 &quot;dec must be in range [0-1024]&quot;
    dec = (dec == 0) ? 1 : dec
    for i in 1:dec
        if 2^i &gt; dec
            return i
        end
    end
    return 0 # should never happen
end

function dec2bin(dec::Int)::Str
    @assert 0 &lt;= dec &lt;= 1024 &quot;dec must be in range [0-1024]&quot;
    nBits::Int = getNumOfBits2codeDec(dec)
    result::Vec{Char} = fill(&#39;0&#39;, nBits)
    bitDec::Int = 2^(nBits-1) # -1, because powers of 2 start at 0 not 1
    for i in eachindex(result)
        if bitDec &lt;= dec
            result[i] = &#39;1&#39;
            dec -= bitDec
        end
        bitDec = div(bitDec, 2)
    end
    return join(result)
end</code></pre>
<p>We begin by declaring <code>getNumOfBits2codeDec</code>, a function that will help us to find how many bits (slots) we need in order to code a given decimal as a binary number. It does so by using a ‘brute force’ approach (<code>for i in 1:dec</code>) with an early stop mechanism (<code>if 2^i &gt; dec</code>). As an alternative we may consider to use the built-in <code>log2</code> function, but the approach presented here just seemed so natural and in line with the previous explanations that I just couldn’t resist.</p>
<p>As for the <code>dec2bin</code> function we start by declaring a few helper variables: <code>nBits</code> - number of bits/slots we need to fill in order to code our number, <code>result</code> - a vector that will hold our final binary representation, and <code>bitDec</code> - a variable that will store the consecutive powers of 2 (expressed in decimal) coded by a given bit. Next, we traverse the bits/slots of our <code>result</code> from left to right. When the current power of two is smaller or equal to the decimal we got to encode (<code>if bitDec &lt;= dec</code>) then we set that particular bit to 1 (<code>result[i] = '1'</code>) and reduce the decimal we still need to encode by that value (<code>dec -= bitDec</code>). Moreover, we update (reduce) our consecutive powers of two (<code>bitDec</code>) by using the 2 divisor (<code>div(bitDec, 2)</code>). <code>div</code> performs an integer division (that drops the decimal part of the quotient). We use it because in the array of the powers of two: <span class="math inline">\(2^4 = 16, 2^3 = 8, 2^2 = 4, 2^1 = 2,
2^0 = 1\)</span> each number gets two times smaller. The <code>div(bitDec, 2)</code> protects us from the case when the integer division by 2 with standard <code>bitDec/2</code> would not be possible (in the last turnover of the loop <code>bitDec</code> will be equal to <code>1</code>).</p>
<p>Let’s see how it works with a couple of numbers.</p>
<pre class="language-julia"><code>lpad.(dec2bin.(0:8), 4, &#39;0&#39;)</code></pre>
<pre class="output"><code>[
&quot;0000&quot;,
&quot;0001&quot;,
&quot;0010&quot;,
&quot;0011&quot;,
&quot;0100&quot;,
&quot;0101&quot;,
&quot;0110&quot;,
&quot;0111&quot;,
&quot;1000&quot;
]</code></pre>
<p>Time for a benchmark against the built-in <code>string</code> function.</p>
<pre class="language-julia"><code>all([dec2bin(i) == string(i, base=2) for i in 0:1024]) # python like
# or simply, more julia style
dec2bin.(0:1024) == string.(0:1024, base=2)</code></pre>
<p>true</p>
<p>It appears we did just fine as the function produces the same results as <code>string</code>.</p>
<p>Once we got it reversing the process should be a breeze.</p>
<pre class="language-julia"><code>function isBin(bin::Char)::Bool
    return bin in [&#39;0&#39;, &#39;1&#39;]
end

function isBin(bin::Str)::Bool
    return isBin.(collect(bin)) |&gt; all
end

function bin2dec(bin::Str)::Int
    @assert isBin(bin) &quot;bin is not a binary number&quot;
    pwr::Int = length(bin) - 1 # -1, because powers of 2 start at 0 not 1
    result::Int = 0
    for b in bin
        result += (b == &#39;1&#39;) ? 2^pwr : 0
        pwr -= 1
    end
    return result
end</code></pre>
<p>Once again, we we start our main function (<code>bin2dec</code>) with the definition of a few helper variables: <code>pwr</code> - which holds a power of the current bit which is in the range from <code>length(bin)-1</code> to <code>0</code> (from the leftmost to the rightmost bit), and <code>result</code> which is just a sum of all bits expressed in decimal system. We build the sum (<code>result +=</code>) bit by bit (<code>for b in bin</code>), but only for the bits equal <code>'1'</code> (<code>(b ==</code>1<code>) ? 2^pwr</code>) while reducing the power for the next bit as we shift right (<code>pwr -= 1</code>). Finally, all that’s left to do is to <code>return</code> the <code>result</code>.</p>
<p>Let’s see how we did.</p>
<pre class="language-julia"><code>lpad.(dec2bin.(0:8), 4, &#39;0&#39;) .|&gt; bin2dec</code></pre>
<pre class="output"><code>[0, 1, 2, 3, 4, 5, 6, 7, 8]</code></pre>
<p>It looks good, and now for a more comprehensive benchmark.</p>
<pre class="language-julia"><code>bin2dec.(string.(0:1024, base=2)) == 0:1024</code></pre>
<p>true</p>
<p>Again, it seems that we can’t complain.</p>
<p>OK, time to add two binaries.</p>
<blockquote>
<p><strong><em>Note:</em></strong> Before you move further, I suggest you take a pen and paper and do the addition and multiplication for some decimals and binaries to get a better grasp of the process that we will translate into Julia’s code.</p>
</blockquote>
<pre class="language-julia"><code># returns (carried bit, running bit)
function add(bin1::Char, bin2::Char)::Tuple{Char, Char}
    @assert isBin(bin1) &amp;&amp; isBin(bin2) &quot;both inputs must be binary bits&quot;
    if bin1 == &#39;1&#39; &amp;&amp; bin2 == &#39;1&#39;
        return (&#39;1&#39;, &#39;0&#39;)
    elseif bin1 == &#39;0&#39; &amp;&amp; bin2 == &#39;0&#39;
        return (&#39;0&#39;, &#39;0&#39;)
    else
        return (&#39;0&#39;, &#39;1&#39;)
    end
end

function getEqlLenBins(bin1::Str, bin2::Str)::Tuple{Str, Str}
    if length(bin1) &gt;= length(bin2)
        return (bin1, lpad(bin2, length(bin1), &#39;0&#39;))
    else
        return getEqlLenBins(bin2, bin1)
    end
end</code></pre>
<p>In order to add two binary numbers we need to define how to add two binary digits (<code>bin1::Char</code> and <code>bin2::Char</code>) first. Just like in the decimal system we need to handle the overflow, e.g. when we add <span class="math inline">\(26 + 8\)</span>, first we add 8 and 6 to get 14. Four (the second digit of 14) becomes the running bit and 1 (the first digit of 14) becomes a carried bit that we add to 2 (the first digit in 26) to get our final score which is 34. By analogy, <code>add(bin1::Char, bin2::Char)</code> returns a tuple (<code>Tuple{Int, Int}</code>) with the carried and running bit, respectively.</p>
<p>Additionally, we defined <code>getEqlLenBins</code> that makes sure the two numbers (<code>bin1</code> and <code>bin2</code>) are of equal length. This is because the upcoming <code>add(bin1::Str, bin2::Str)</code> will rely on the above <code>add(bin1::Char, bin2::Char)</code>, that’s why the shorter number will be padded on the left with zeros (by <code>lpad</code>), which is a neutral digit in addition (in decimal adding 26+8 is the same as adding 26+08). Two points of notice. First of all, make sure to use <code>&gt;=</code> and not <code>&gt;</code> in the first <code>if</code> statement otherwise you will end up with an infinite recursion (see Section <a href="./recursion.html#sec:recursion">7</a>) and <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a> error in some cases (test yourself and explain why it will happen for <code>getEqlLenBins("01", "10")</code>). Secondly, the recursive call <code>getEqlLenBins(bin2, bin1)</code> effectively swaps the numbers. This is a neat trick and makes no difference here (since addition and multiplication are <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a>), but may cause troubles otherwise. Anyway, time for <code>add(bin1::Str, bin2::Str)</code>.</p>
<pre class="language-julia"><code>function isZero(bin::Char)::Bool
    return bin == &#39;0&#39;
end

function isZero(bin::Str)::Bool
    return isZero.(collect(bin)) |&gt; all
end

function add(bin1::Str, bin2::Str)::Str
    @assert isBin(bin1) &amp;&amp; isBin(bin2) &quot;both inputs must be binary numbers&quot;
    bin1, bin2 = getEqlLenBins(bin1, bin2)
    carriedBit::Char = &#39;0&#39;
    runningBit::Char = &#39;0&#39;
    runningBits::Str = &quot;&quot;
    carriedBits::Str = &quot;0&quot;
    for (b1, b2) in zip(reverse(bin1), reverse(bin2))
        carriedBit, runningBit = add(b1, b2)
        runningBits = runningBit * runningBits
        carriedBits = carriedBit * carriedBits
    end
    if isZero(carriedBits)
        return isZero(runningBits) ? &quot;0&quot; : lstrip(isZero, runningBits)
    else
        return add(runningBits, carriedBits)
    end
end</code></pre>
<p>The key function is rather simple. First, we align the binaries to contain the same number of bits/slots (<code>getEqlLenBins</code>) and declare (+ initialize) a few helper variables. Next, we move from right to left (<code>reverse</code> functions) by the corresponding bits (<code>b1</code>, <code>b2</code>) of our binary numbers (<code>bin1</code> and <code>bin2</code>). We add the bits together (<code>add(b1, b2)</code>) and prepend (<code>*</code> - glues <code>Char</code>s and <code>String</code>s together) the obtained <code>runningBit</code> and <code>carriedBit</code> to <code>runningBits</code> and <code>carriedBits</code>, respectively. Once we traveled every bit of <code>bin1</code> and <code>bin2</code> (thanks to the <code>for</code> loop). We check if the <code>carriedBits</code> is equal to zero (i.e. all bits are equal <code>0</code>). If so (<code>if isZero(carriedBits)</code>), then we <code>return</code> our <code>runningBits</code> but without the excessive zeros (<code>lstrip(isZero, runningBits)</code>) that might have been produced on the left site (since e.g. the binary <code>010</code> is the same as <code>10</code>, just like the decimal <code>03</code> is the same as <code>3</code>). However, if <code>runningBits</code> is equal zero (<code>isZero(runningBits) ?</code>) we return <code>"0"</code> (because in this case <code>lstrip</code> would have returned an empty string, i.e. <code>""</code>). Otherwise (<code>else</code>), we just add the carried bits to the running bits (recursive <code>add(runningBits, carriedBits)</code> call). Notice, that in order for the last statement to work <code>carriiedBits</code> need to be moved by 1 to the left with respect to the <code>runningBits</code>. That is why, we initialized them with <code>"0"</code> and not an empty string <code>""</code> in the first place (<code>carriedBits::Str = "0"</code>). If the last two sentences are not clear, then go ahead take a pen and paper and add two simple decimals with the carry (like in the primary school). Then you will see that the carried bit is moved to the left.</p>
<p>Some test would be in order. And here is our testing powerhouse.</p>
<pre class="language-julia"><code># binFn(Str, Str) -&gt; Str, decFn(Int, Int) -&gt; Int
function doesBinFnWork(dec1::Int, dec2::Int,
                       binFn::Function, decFn::Function)::Bool
    bin1::Str = binFn(dec2bin(dec1), dec2bin(dec2))
    bin2::Str = string(decFn(dec1, dec2), base=2)
    return bin1 == bin2
end</code></pre>
<p><code>doesBinFnWork</code> accepts two decimals (<code>dec1</code>, <code>dec2</code>) and two functions (<code>binFn</code>, <code>decFn</code>) as its arguments. Each of the functions should accept two arguments (<code>binFn</code> binaries, and <code>decFn</code> decimals) and perform the same operation on them. Notice, that inside of <code>doesBinFnWork</code> both <code>dec1</code> and <code>dec2</code> are converted to binaries and send to <code>binFn</code>, whereas the result of <code>decFn(dec1, dec2)</code> is converted to binary. In the end <code>bin1</code> and <code>bin2</code> are compared to make sure that they are mathematically equal. All set, time for a test.</p>
<pre class="language-julia"><code># running this test may take a few seconds (513x513 matrix)
tests = [doesBinFnWork(a, b, add, +) for a in 0:512, b in 0:512]
all(tests)</code></pre>
<p>true</p>
<p>Another day, another dollar. Time for the multiplication.</p>
<pre class="language-julia"><code>function multiply(bin1::Char, bin2::Char)::Char
    @assert isBin(bin1) &amp;&amp; isBin(bin2) &quot;both inputs must be binary bits&quot;
    if bin1 == &#39;1&#39; &amp;&amp; bin2 == &#39;1&#39;
        return &#39;1&#39;
    else
        return &#39;0&#39;
    end
end

function multiply(bin1::Str, bin2::Str)::Str
    @assert isBin(bin1) &amp;&amp; isBin(bin2) &quot;both inputs must be binary numbers&quot;
    total::Str = &quot;0&quot;
    curProd::Str = &quot;0&quot;
    zerosToPad::Int = 0
    for b in reverse(bin2)
        curProd = multiply.(b, collect(bin1)) |&gt; join
        total = add(total, curProd * &quot;0&quot;^zerosToPad)
        zerosToPad += 1
    end
    return total
end</code></pre>
<p>Again, we begin by defining how to multiply two individual bits, and again it resembles the multiplication in the decimal system. Once we got it, we move to multiply the whole numbers (<code>mulitply(bin1::Str, bin2::Str</code>)). Just like in the decimal system we multiply all the bits (from right to left) from the second number (<code>for b in reverse(bin2)</code>) by the bits in the first number (<code>multiply.(b, collect(bin1)) |&gt; join</code>). After each multiplication the product (<code>curProd</code>) of <code>b</code> times <code>bin1</code> is summed (<code>add(total, curProd * "0"^zerosToPad</code>)) into a grand <code>total</code>. Just like in the decimal system, <code>curProd</code> is shifted to left every time we do that, which is why we defined and increased <code>zerosToPad</code> variable. Let’s test it out.</p>
<pre class="language-julia"><code># 33x33 matrix so it should be relatively fast
tests = [doesBinFnWork(a, b, multiply, *) for a in 0:32, b in 0:32]
all(tests)</code></pre>
<p>true</p>
<p>I guess we did it again. Good for us.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./binary_problem.html"><b>13.1</b> Problem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./leap_year.html"><b>14</b> Leap year</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>
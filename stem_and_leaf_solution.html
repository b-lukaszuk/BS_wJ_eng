<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solution - Build SH*T with Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Build SH*T with Julia</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./mat_multip.html"><b>2</b> Matrix Multiplication</a></li>
<li><a class="menu-level-2" href="./mat_multip_problem.html"><b>2.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mat_multip_solution.html"><b>2.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bat_and_ball.html"><b>3</b> Bat and Ball</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_problem.html"><b>3.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_solution.html"><b>3.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./toothpaste.html"><b>4</b> Toothpaste</a></li>
<li><a class="menu-level-2" href="./toothpaste_problem.html"><b>4.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./toothpaste_solution.html"><b>4.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bile.html"><b>5</b> Bile</a></li>
<li><a class="menu-level-2" href="./bile_problem.html"><b>5.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bile_solution.html"><b>5.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./prime_numbers.html"><b>6</b> Prime Numbers</a></li>
<li><a class="menu-level-2" href="./prime_numbers_problem.html"><b>6.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./prime_numbers_solution.html"><b>6.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./logo.html"><b>7</b> Logo</a></li>
<li><a class="menu-level-2" href="./logo_problem.html"><b>7.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./logo_solution.html"><b>7.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./transcription.html"><b>8</b> Transcription</a></li>
<li><a class="menu-level-2" href="./transcription_problem.html"><b>8.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./transcription_solution.html"><b>8.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./translation.html"><b>9</b> Translation</a></li>
<li><a class="menu-level-2" href="./translation_problem.html"><b>9.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./translation_solution.html"><b>9.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./stem_and_leaf.html"><b>10</b> Stem and Leaf Plot</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>10.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_solution.html"><b>10.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./altruism.html"><b>11</b> Altruism</a></li>
<li><a class="menu-level-2" href="./altruism_problem.html"><b>11.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./altruism_solution.html"><b>11.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the-end.html"><b>12</b> The end</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="10.2" id="sec:stem_and_leaf_solution"><span class="header-section-number">10.2</span> Solution</h2>
<p>Let’s start with a helper function that returns the number of characters that compose a number.</p>
<pre class="language-julia"><code>function howManyChars(num::Int)::Int
    return num |&gt; string |&gt; length
end</code></pre>
<p>The function is quite simple, it sends (<code>|&gt;</code>) a number (<code>num</code>) to <code>string</code> (converts a number to its textual representation) and redirects the result (<code>|&gt;</code>) to <code>length</code>. I find this form clearer that the equivalent <code>length(string(num))</code> or <code>string(num) |&gt; length</code> or <code>(length ∘ string)(num)</code> (<code>∘</code> is a <a href="https://docs.julialang.org/en/v1/manual/functions/#Function-composition-and-piping">function composition operator</a> that you obtain by typing <code>\circ</code> and pressing Tab).</p>
<p>Time for a test run.</p>
<pre class="language-julia"><code>map(howManyChars, [5, -8, -11, 303])</code></pre>
<pre class="output"><code>[1, 2, 3, 3]</code></pre>
<p>Appears to be working fine.</p>
<p>Now let’s write a function that takes a vector of integers and returns the number of characters in the longest of them (we will need it to determine the width of the stem later on).</p>
<pre class="language-julia"><code>function getMaxLengthOfNum(nums::Vec{Int})::Int
    maxLen::Int = map(howManyChars, nums) |&gt; maximum
    return max(2, maxLen)
end</code></pre>
<blockquote>
<p>Note. Instead of <code>map(howManyChars, nums)</code> above we could have just used <code>map(length ∘ string, nums)</code>. This would save us some typing (no need to define <code>howManyChars</code> in the first place), but made the code a bit more cryptic at first read.</p>
</blockquote>
<p>Again, a piece of cake, we just use <code>map</code> to apply <code>howManyChars</code> to every number in a vector (<code>nums</code>) and get the length of the longest number by sending (<code>|&gt;</code>) the lengths to <code>maximum</code>. Notice, that the function doesn’t return the expected <code>maxLen</code>. This is because in a moment, we will write <code>getStemAndLeaf(num::Int, maxLenOfNum::Int)</code> that brakes a number into two parts: stem and leaf. It will require <code>maxLenOfNum</code> to be at least 2 (so that at least one digit serves as a stem and one as a leaf), hence return <code>max(2, maxLen)</code>.</p>
<pre class="language-julia"><code>function getStemAndLeaf(num::Int, maxLenOfNum::Int)::Tuple{Str, Str}
    @assert maxLenOfNum &gt; 1 &quot;maxLenOfNum must be greater than 1&quot;
    @assert howManyChars(num) &lt;= maxLenOfNum
        &quot;character count in num must be &lt;= maxLenOfNum&quot;
    numStr::Str = lpad(abs(num), maxLenOfNum, &quot;0&quot;)
    stem::Str = numStr[1:end-1] |&gt; string
    leaf::Str = numStr[end] |&gt; string
    stem = parse(Int, stem) |&gt; string #1
    stem = num &lt; 0 ? &quot;-&quot; * stem : stem #2
    stem = lpad(stem, maxLenOfNum-1, &quot; &quot;) #3
    return (stem, leaf)
end</code></pre>
<p>We begin with <code>lpad</code>. This function converts its first input (<code>abs(num)</code>) to string of a given length (<code>maxLenOfNum</code>). It adds a padding (<code>"0"</code>) to the left side of the result (if necessary) in order to obtain the string with a desired number of characters. Next, we proceed to obtain the <code>stem</code> which contains all the characters from <code>numStr</code>, except the last one (<code>end-1</code>). The <code>|&gt; string</code> makes sure that the end result is <code>Str</code> (since, e.g. <code>stem</code> from <code>"21"</code> would be <code>'2'</code> which is of type <code>Char</code>). Similarly, we produce <code>leaf</code> by taking the last character of <code>numStr</code>. We could stop here, and it would likely work fine for a positive integer. However, handling broader range of inputs (<code>num</code> and <code>maxLenOfNum</code>) requires some further <code>stem</code> processing. Hence the lines designated with <code>#1-#3</code> that were added in later iterations of <code>getStemAndLeaf</code>.<code>#1</code> removes superfluous 0s from the left side of the string (e.g. <code>"001"</code> becomes <code>"1"</code> and <code>"00"</code> becomes <code>"0"</code>). <code>#2</code> adds <code>"-"</code> sign if the input (<code>num</code>) was negative. <code>#3</code> aligns the text (<code>stem</code>) to the right. It does so by adding spaces (<code>" "</code>) to the left site of <code>stem</code>. All that’s left to do is to <code>return</code> our <code>stem</code> and <code>leaf</code> and see how it works for some exemplary inputs.</p>
<pre class="language-julia"><code>Dict(n =&gt; getStemAndLeaf(n, 3) for n in [-12, -3, 3, 8, 10, 145])</code></pre>
<pre class="output"><code>Dict{Int64, Tuple{String, String}} with 6 entries:
  -12 =&gt; (&quot;-1&quot;, &quot;2&quot;)
  10 =&gt; (&quot; 1&quot;, &quot;0&quot;)
  145 =&gt; (&quot;14&quot;, &quot;5&quot;)
  -3 =&gt; (&quot;-0&quot;, &quot;3&quot;)
  8 =&gt; (&quot; 0&quot;, &quot;8&quot;)
  3 =&gt; (&quot; 0&quot;, &quot;3&quot;)</code></pre>
<p>Time to write <code>getLeafCounts</code> a function that for a vector of numbers returns a mapping (<code>Dict</code>) between stems (keys) and leaves (values).</p>
<pre class="language-julia"><code># returns Dict{stem, [leaves]}
function getLeafCounts(nums::Vec{Int},
    maxLenOfNum::Int)::Dict{Str, Vec{Str}}
    @assert length(unique(nums)) &gt; 1 &quot;numbers musn&#39;t be the same&quot;
    counts::Dict{Str, Vec{Str}} = Dict()
    for num in nums
        stem, leaf = getStemAndLeaf(num, maxLenOfNum) # for&#39;s local vars
        if haskey(counts, stem)
            counts[stem] = push!(counts[stem], leaf)
        else
            counts[stem] = [leaf]
        end
    end
    return counts
end</code></pre>
<p>First, we initialize an empty <code>Dict</code> (<code>counts</code>) that will hold our result. Next, we brake each number (<code>for num in nums</code>) into <code>stem</code> and <code>leaf</code> parts. If the <code>counts</code> the already contains such a <code>stem</code> (<code>haskey(counts, stem)</code>), then we add the <code>leaf</code> to the vector of already existing leaves (<code>push!(counts[stem], leaf)</code>). Otherwise (<code>else</code>), we add a <code>leaf</code> as a 1-element vector (<code>[leaf</code>]) for a given <code>stem</code>. Finally, we return the <code>counts</code>.</p>
<p>Let’s see how it works.</p>
<pre class="language-julia"><code># prime numbers below 100
primesLeafCounts = getLeafCounts(
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,
        53, 59, 61, 67, 71, 73, 79, 83, 89, 97],
    2
)</code></pre>
<pre class="output"><code>Dict{String, Vector{String}} with 10 entries:
  &quot;8&quot; =&gt; [&quot;3&quot;, &quot;9&quot;]
  &quot;4&quot; =&gt; [&quot;1&quot;, &quot;3&quot;, &quot;7&quot;]
  &quot;1&quot; =&gt; [&quot;1&quot;, &quot;3&quot;, &quot;7&quot;, &quot;9&quot;]
  &quot;5&quot; =&gt; [&quot;3&quot;, &quot;9&quot;]
  &quot;0&quot; =&gt; [&quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;]
  &quot;2&quot; =&gt; [&quot;3&quot;, &quot;9&quot;]
  &quot;6&quot; =&gt; [&quot;1&quot;, &quot;7&quot;]
  &quot;7&quot; =&gt; [&quot;1&quot;, &quot;3&quot;, &quot;9&quot;]
  &quot;9&quot; =&gt; [&quot;7&quot;]
  &quot;3&quot; =&gt; [&quot;1&quot;, &quot;7&quot;]</code></pre>
<p>Looks, alright. Time to pretty print the result. First, let’s get a formatted row.</p>
<pre class="language-julia"><code>function getStemLeafRow(key::Str, leafCounts::Dict{Str, Vec{Str}})::Str
    row::Str = key * &quot;|&quot;
    if haskey(leafCounts, key)
        row *= sort(leafCounts[key]) |&gt; join
    end
    return row * &quot;\n&quot;
end</code></pre>
<p>We define our <code>row</code> as a string that contains the <code>key</code> and separator. If our <code>leafCounts</code> contains a given <code>key</code> then we append its sorted values concatenated together with <code>join</code> function (e.g., <code>["1", "1", "3"] |&gt; join</code> becomes <code>"113"</code>). We return <code>row</code> with a newline character (<code>\n</code>).</p>
<p>Time for the whole stem and leaf plot.</p>
<pre class="language-julia"><code>function getStemLeafPlot(nums::Vec{Int})::Str
    maxLenOfNum::Int = getMaxLengthOfNum(nums)
    leafCounts::Dict{Str, Vec{Str}} = getLeafCounts(nums, maxLenOfNum)
    low::Int, high::Int = extrema(nums)
    testedStems::Dict{Str, Bool} = Dict()
    result::Str = &quot;&quot;
    for num in low:1:high
        stem, _ = getStemAndLeaf(num, maxLenOfNum)
        if haskey(testedStems, stem)
            continue
        end
        result *= getStemLeafRow(stem, leafCounts)
        testedStems[stem] = true
    end
    return result
end</code></pre>
<p>At the onset, we define a few variables. Some of them deserve a short explanation. <code>low</code> and <code>high</code> are the two <code>extrema</code> (minimum and maximum) of our numbers (<code>nums</code>). <code>testedStems</code> will contain the keys from <code>leafCounts</code>, i.e. the stems from our stem-leaf plot that rows has been already obtained. Next, we use <code>for</code> loop to travel through all the numbers in our range (<code>low</code> to <code>high</code>). For each tested number (<code>num</code>) we get its <code>stem</code>. If the <code>stem</code> was already obtained (<code>if haskey</code>) we <code>continue</code> to another <code>for</code> loop iteration. Otherwise, we add the row to our <code>result</code> (<code>result *= getStemLeafRow</code>) and insert the <code>stem</code> among the already visited (<code>testedStems[stem] = true</code>). When we finish we return the whole stem-leaf-plot (<code>return result</code>).</p>
<p>And that’s it. Let’s see how it works on <a href="https://en.wikipedia.org/wiki/Stem-and-leaf_display">Wikipedia’s examples</a>. First, prime numbers below 100:</p>
<pre>
getStemLeafPlot(stemLeafTest1)
</pre>
<pre>
0|2357
1|1379
2|39
3|17
4|137
5|39
6|17
7|139
8|39
9|7
</pre>
<p>Now, the numbers from the Construction section:</p>
<pre>
getStemLeafPlot(stemLeafTest2)
</pre>
<pre>
 4|4679
 5|
 6|34688
 7|2256
 8|148
 9|
10|6
</pre>
<p>All that’s left to do is to adjust our function for the example with floats.</p>
<pre class="language-julia"><code>function getStemLeafPlot(nums::Vec{Flt})::Str
    ints::Vec{Int} = round.(Int, nums)
    return getStemLeafPlot(ints)
end</code></pre>
<p>And voila:</p>
<pre>
getStemLeafPlot(stemLeafTest3)
</pre>
<pre>
-2|4
-1|2
-0|3
 0|466
 1|7
 2|5
 3|
 4|
 5|7
</pre>
<p>It appears to be working as intended so I think we can finish here.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>10.1</b> Problem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./altruism.html"><b>11</b> Altruism</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>
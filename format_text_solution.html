<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Bartlomiej Lukaszuk" />
  <title>Solution - Build SH*T with Julia</title>
  <link rel="stylesheet" href="./style.css"/>
    <script src="./mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("./JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./github.min.css">
<script src="./highlight.min.js"></script>
<script src="./julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="./">Build SH*T with Julia</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="./about.html"><b>1</b> About</a></li>
<li><a class="menu-level-1" href="./mat_multip.html"><b>2</b> Matrix Multiplication</a></li>
<li><a class="menu-level-2" href="./mat_multip_problem.html"><b>2.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mat_multip_solution.html"><b>2.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bat_and_ball.html"><b>3</b> Bat and Ball</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_problem.html"><b>3.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bat_and_ball_solution.html"><b>3.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./camel_case.html"><b>4</b> Camel case</a></li>
<li><a class="menu-level-2" href="./camel_case_problem.html"><b>4.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./camel_case_solution.html"><b>4.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./toothpaste.html"><b>5</b> Toothpaste</a></li>
<li><a class="menu-level-2" href="./toothpaste_problem.html"><b>5.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./toothpaste_solution.html"><b>5.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./bile.html"><b>6</b> Bile</a></li>
<li><a class="menu-level-2" href="./bile_problem.html"><b>6.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./bile_solution.html"><b>6.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./recursion.html"><b>7</b> Recursion</a></li>
<li><a class="menu-level-2" href="./recursion_problem.html"><b>7.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./recursion_solution.html"><b>7.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./randomness.html"><b>8</b> Randomness</a></li>
<li><a class="menu-level-2" href="./randomness_problem.html"><b>8.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./randomness_solution.html"><b>8.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the_doors.html"><b>9</b> The Doors</a></li>
<li><a class="menu-level-2" href="./the_doors_problem.html"><b>9.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./the_doors_solution.html"><b>9.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./progress_bar.html"><b>10</b> Progress Bar</a></li>
<li><a class="menu-level-2" href="./progress_bar_problem.html"><b>10.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./progress_bar_solution.html"><b>10.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./pascals_triangle.html"><b>11</b> Pascal’s triangle</a></li>
<li><a class="menu-level-2" href="./pascals_triangle_problem.html"><b>11.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./pascals_triangle_solution.html"><b>11.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./canvas.html"><b>12</b> Canvas</a></li>
<li><a class="menu-level-2" href="./canvas_problem.html"><b>12.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./canvas_solution.html"><b>12.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./tree.html"><b>13</b> Tree</a></li>
<li><a class="menu-level-2" href="./tree_problem.html"><b>13.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./tree_solution.html"><b>13.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./format_text.html"><b>14</b> Format text</a></li>
<li><a class="menu-level-2" href="./format_text_problem.html"><b>14.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./format_text_solution.html"><b>14.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./roman_numerals.html"><b>15</b> Roman numerals</a></li>
<li><a class="menu-level-2" href="./roman_numerals_problem.html"><b>15.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./roman_numerals_solution.html"><b>15.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./cheque.html"><b>16</b> Cheque</a></li>
<li><a class="menu-level-2" href="./cheque_problem.html"><b>16.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./cheque_solution.html"><b>16.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./binary.html"><b>17</b> Binary</a></li>
<li><a class="menu-level-2" href="./binary_problem.html"><b>17.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./binary_solution.html"><b>17.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./leap_year.html"><b>18</b> Leap year</a></li>
<li><a class="menu-level-2" href="./leap_year_problem.html"><b>18.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./leap_year_solution.html"><b>18.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./calendar.html"><b>19</b> Calendar</a></li>
<li><a class="menu-level-2" href="./calendar_problem.html"><b>19.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./calendar_solution.html"><b>19.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./prime_numbers.html"><b>20</b> Prime Numbers</a></li>
<li><a class="menu-level-2" href="./prime_numbers_problem.html"><b>20.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./prime_numbers_solution.html"><b>20.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./tic_tac_toe.html"><b>21</b> Tic-tac-toe</a></li>
<li><a class="menu-level-2" href="./tic_tac_toe_problem.html"><b>21.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./tic_tac_toe_solution.html"><b>21.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./touch_typing.html"><b>22</b> Touch Typing</a></li>
<li><a class="menu-level-2" href="./touch_typing_problem.html"><b>22.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./touch_typing_solution.html"><b>22.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./birthday.html"><b>23</b> Birthday</a></li>
<li><a class="menu-level-2" href="./birthday_problem.html"><b>23.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./birthday_solution.html"><b>23.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./compound_interest.html"><b>24</b> Compound interest</a></li>
<li><a class="menu-level-2" href="./compound_interest_problem.html"><b>24.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./compound_interest_solution.html"><b>24.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./mortgage.html"><b>25</b> Mortgage</a></li>
<li><a class="menu-level-2" href="./mortgage_problem.html"><b>25.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./mortgage_solution.html"><b>25.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./overpayment.html"><b>26</b> Overpayment</a></li>
<li><a class="menu-level-2" href="./overpayment_problem.html"><b>26.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./overpayment_solution.html"><b>26.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./logo.html"><b>27</b> Logo</a></li>
<li><a class="menu-level-2" href="./logo_problem.html"><b>27.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./logo_solution.html"><b>27.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./lattice_paths.html"><b>28</b> Lattice Paths</a></li>
<li><a class="menu-level-2" href="./lattice_paths_problem.html"><b>28.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./lattice_paths_solution.html"><b>28.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./transcription.html"><b>29</b> Transcription</a></li>
<li><a class="menu-level-2" href="./transcription_problem.html"><b>29.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./transcription_solution.html"><b>29.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./translation.html"><b>30</b> Translation</a></li>
<li><a class="menu-level-2" href="./translation_problem.html"><b>30.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./translation_solution.html"><b>30.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./stem_and_leaf.html"><b>31</b> Stem and Leaf Plot</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_problem.html"><b>31.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./stem_and_leaf_solution.html"><b>31.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./altruism.html"><b>32</b> Altruism</a></li>
<li><a class="menu-level-2" href="./altruism_problem.html"><b>32.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./altruism_solution.html"><b>32.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./shift.html"><b>33</b> Shift</a></li>
<li><a class="menu-level-2" href="./shift_problem.html"><b>33.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./shift_solution.html"><b>33.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./caesar.html"><b>34</b> Caesar</a></li>
<li><a class="menu-level-2" href="./caesar_problem.html"><b>34.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./caesar_solution.html"><b>34.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./vigenere.html"><b>35</b> Vigenere</a></li>
<li><a class="menu-level-2" href="./vigenere_problem.html"><b>35.1</b> Problem</a></li>
<li><a class="menu-level-2" href="./vigenere_solution.html"><b>35.2</b> Solution</a></li>
<li><a class="menu-level-1" href="./the-end.html"><b>36</b> The end</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="14.2" id="sec:format_text_solution"><span class="header-section-number">14.2</span> Solution</h2>
<p>Before we begin, let’s define a few <a href="https://docs.julialang.org/en/v1/base/base/#const">const</a>ants that will be used throughout the program.</p>
<pre><code>const PAD = &quot; &quot;
const COL_SEP = PAD ^ 4
const MAX_LINE_LEN = 60</code></pre>
<p>Next, our first step in formatting a paragraph will be to break it into lines, each with the length smaller than or equal to some target value.</p>
<pre><code>function getLines(txt::Str, targetLineLen::Int=MAX_LINE_LEN)::Vec{Str}
    @assert 19 &lt; targetLineLen &lt; 61 &quot;targetLineLen must be in range [20-60]&quot;
    words::Vec{Str} = split(txt)
    lines::Vec{Str} = []
    curLine::Str = &quot;&quot;
    difference::Int = 0
    for word in words
        difference = targetLineLen - length(curLine) - length(word)
        if difference &gt;= 0
            curLine *= word * PAD
        else
            push!(lines, strip(curLine))
            curLine = word * PAD
        end
    end
    push!(lines, strip(curLine))
    return lines
end</code></pre>
<p>For that we break our text (<code>txt</code>) into <code>words</code> with the <a href="https://docs.julialang.org/en/v1/base/strings/#Base.split">split</a> function. Then, <code>for</code> each <code>word</code> we calculate the <code>difference</code> between our desired line length (<code>targetLineLen</code>) and the current line length (<code>length(curLine)</code>) plus the length of the word (<code>length(word)</code>) we want to add to that line. If we still got room for one more word (<code>if difference &gt;= 0</code>) then we just add it with a padding on the right side (<code>curLine *= word *  PAD</code>). Otherwise (<code>else</code>), we add <code>curLine</code> to the vector of <code>lines</code> with <code>push!</code> and make our <code>word</code> the beginning of a new line (<code>curLine = word *  PAD</code>). Notice, that before <code>push</code>ing the old line to the collection, first, we <code>strip</code>ped it from any possible extra spaces on the edges. Afterwards (<code>end</code> of <code>for</code>), we <code>push</code> the last line to <code>lines</code> and return the latter from inside the function.</p>
<p>Now, for left-, right- and center alignment, each line will have to be padded with space characters (<code>PAD</code>) placed on the right, left, and both sides, respectively. For that we need to know the difference between the number of characters in our line and its target length. Moreover, we need a padding function that we will name <code>padLine</code> (to practice coding even more we will not use the built in <a href="https://docs.julialang.org/en/v1/base/strings/#Base.lpad">lpad</a> and <a href="https://docs.julialang.org/en/v1/base/strings/#Base.rpad">rpad</a>). Notice, the usage of the <code>*</code> operator that glues two strings together and the <code>^</code> symbol that repeats the sting on its left the number of times on its right (remember about the operator precedence from mathematics).</p>
<pre><code>function getLenDiffs(lines::Vec{Str},
                     targetLineLen::Int=MAX_LINE_LEN)::Vec{Int}
    return targetLineLen .- map(length, lines)
end

function padLine(line::Str, lPadLen::Int, rPadLen::Int,
                 lPad::Str=PAD, rPad::Str=PAD)::Str
    @assert lPadLen &gt;= 0 &amp;&amp; rPadLen &gt;= 0 &quot;padding lengths must be &gt;= 0&quot;
    return lPad ^ lPadLen * line * rPad ^ rPadLen
end</code></pre>
<p>Once we got it, padding lines should be a breeze.</p>
<pre><code>function getPaddedLines(lines::Vec{Str},
                         lPadsLens::Vec{Int}, rPadsLens::Vec{Int})::Vec{Str}
    @assert(length(lines) == length(lPadsLens) == length(rPadsLens),
            &quot;all vectors must be of equal lengths&quot;)
    return map(padLine, lines, lPadsLens, rPadsLens)
end</code></pre>
<p>Here, similarly to Section <a href="./mat_multip_solution.html#sec:mat_multip_solution">2.2</a>, we use <a href="https://docs.julialang.org/en/v1/base/collections/#Base.map">map</a>, which applies a function (<code>padLine</code>) to every consecutive elements of <code>lines</code>, <code>lPadsLens</code> and <code>rPadsLens</code> in turn. So it goes like: <code>padLine(lines[1], lPadsLens[1], rPadsLens[1])</code> and <code>padLine(lines[2], lPadsLens[2], rPadsLens[2])</code>, etc., and collects the results into a vector.</p>
<p>Now, the formatting reduces down to obtaining the lines, and calculating the diffs, which we do on the fly with this code snippet (<code>div(x, y)</code> divides <code>x</code> by <code>y</code> and returns an integer by dropping fractional part when necessary).</p>
<pre><code>function getLeftAlignedLines(txt::Str,
                             targetLineLen::Int=MAX_LINE_LEN)::Vec{Str}
    lines::Vec{Str} = getLines(txt, targetLineLen)
    rPadsLens::Vec{Int} = getLenDiffs(lines, targetLineLen)
    return getPaddedLines(lines, zeros(Int, length(lines)), rPadsLens)
end

function getRightAlignedLines(txt::Str,
                              targetLineLen::Int=MAX_LINE_LEN)::Vec{Str}
    lines::Vec{Str} = getLines(txt, targetLineLen)
    lPadsLens::Vec{Int} = getLenDiffs(lines, targetLineLen)
    return getPaddedLines(lines, lPadsLens, zeros(Int, length(lines)))
end

function getCenteredLines(txt::Str,
                          targetLineLen::Int=MAX_LINE_LEN)::Vec{Str}
    lines::Vec{Str} = getLines(txt, targetLineLen)
    diffs::Vec{Int} = getLenDiffs(lines, targetLineLen)
    lPadLens::Vec{Int} = div.(diffs, 2)
    rPadLens::Vec{Int} = diffs .- lPadLens
    return getPaddedLines(lines, lPadLens, rPadLens)
end

function printLines(lines::Vec{Str})::Nothing
    join(lines, &quot;\n&quot;) |&gt; print
    return nothing
end</code></pre>
<p>Go ahead, test it out (e.g. <code>getCenteredLines(lorem) |&gt; printLines</code>) and see how it works.</p>
<p>OK, time for a function that will justify our line (<code>justifyLine</code>). Here, our approach will be slightly different. First, we’ll break the line into words (with <code>split</code>). Then, we’ll figure out how many regular (<code>nSpacesBtwnWords</code>) spaces and extra spaces (<code>nExtraSpaces</code>) between the words we need. Finally, we’ll place the extra spaces in random places (with <code>getSample</code>) between the words (with <code>intercalate</code>).</p>
<pre><code># draws n random elements from v (without replacement)
function getSample(v::Vec{A}, n::Int)::Vec{A} where A
    @assert 0 &lt;= n &lt;= length(v) &quot;n must be in range [0-length(v)]&quot;
    return Rnd.shuffle(v)[1:n]
end

function intercalate(v1::Vec{Str}, v2::Vec{Str})::Str
    @assert(length(v1) == (length(v2)+1),
            &quot;length(v1) must be equal length(v2)+1&quot;)
    return join(map(*, v1, v2)) * v1[end]
end

function justifyLine(line::Str, lastLine::Bool=false,
                     targetLineLen::Int=MAX_LINE_LEN)::Str
    words::Vec{Str} = split(line)
    if  length(words) &lt; 2 || lastLine
        return padLine(line, 0, targetLineLen - length(line))
    end
    nSpacesBtwnWords::Int = length(words) - 1
    nSpacesTotal::Int = targetLineLen - sum(map(length, words))
    spaceBtwnWordsLen::Int = div(nSpacesTotal, nSpacesBtwnWords)
    nExtraSpaces::Int = nSpacesTotal - nSpacesBtwnWords * spaceBtwnWordsLen
    spaces::Vec{Str} = fill(PAD ^ spaceBtwnWordsLen, nSpacesBtwnWords)
    inds::Vec{Int} = getSample(collect(eachindex(spaces)), nExtraSpaces)
    spaces[inds] .*= PAD
    return intercalate(words, spaces)
end</code></pre>
<p>Let’s briefly discuss some of the more interesting parts of the code snippet. We start by determining how many spaces between the words there are (<code>nSpacesBtwnWords</code>) and how many spaces in total we need in order to reach our <code>targetLineLen</code> (<code>nSpacesTotal</code>). In the perfect world, <code>nSpacesTotal</code> should divide by <code>nSpacesBtwnWords</code> evenly (<code>spaceBtwnWordsLen</code> should be an integer). To help that happen we use <code>div</code> (it drops the fractional part). Moreover, we also account for the possible extra spaces needed (<code>nExtraSpaces</code>, when the dropped fractional part was greater than 0). Once we got it, we get a vector of regular spaces between the words and place it in <code>spaces</code>. Then, we draw random indices (<code>inds</code>) from <code>spaces</code> to which we will add a single extra space (<code>PAD</code>). Notice that <code>spaces[inds] .= PAD</code> would replace every element of <code>spaces</code> (indicated by <code>inds</code>) with <code>PAD</code>. Instead, <code>spaces[inds] .*= PAD</code> will take every element and update it (<code>*=</code>) with <code>PAD</code>, which in this case means just appending (<code>*</code>) <code>PAD</code> (a string) to the string that was previously in an element of <code>spaces</code>. Finally, we intercalate <code>words</code> in a <code>line</code> with <code>spaces</code> (regular and extra), which we <code>return</code>. And voila, all that’s left to do is to justify every line</p>
<pre><code>function getJustifiedLines(txt::Str,
                           targetLineLen::Int=MAX_LINE_LEN)::Vec{Str}
    lines::Vec{Str} = getLines(txt, targetLineLen)
    return map(line -&gt; justifyLine(
        line, line == lines[end], targetLineLen), lines)
end</code></pre>
<p>and test it out (<code>getJustifiedLines(lorem) |&gt; printLines</code>).</p>
<p>As for the double column justified layout, it’s pretty straightforward. We’ll get a single justified column (that is roughly half the width of <code>MAX_LINE_LEN</code>), split it approximately in half and glue together lines from adjacent columns. Let’s get into it.</p>
<pre><code>function connectColumns(col1lines::Vec{Str}, col2lines::Vec{Str})::Vec{Str}
    @assert(length(col1lines) &gt;= length(col2lines),
            &quot;col1lines must have &gt;= elements than col2lines&quot;)
    result::Vec{Str} = fill(&quot;&quot;, length(col1lines))
    emptyColPad = padLine(&quot;&quot;, 0, length(col1lines[1]))
    for i in eachindex(col1lines)
        result[i] = string(col1lines[i], COL_SEP,
                           get(col2lines, i, emptyColPad))
    end
    return result
end

function getDoubleColumn(txt::Str,
                         targetLineLen::Int=MAX_LINE_LEN)::Vec{Str}
    @assert 19 &lt; targetLineLen &lt; 61 &quot;targetLineLen must be in range [20-60]&quot;
    lines::Vec{Str} = getJustifiedLines(
        txt, div(targetLineLen, 2) - div(length(COL_SEP), 2), ) # 2 - nCols
    midPoint::Int = ceil(Int, length(lines)/2)
    return connectColumns(lines[1:midPoint], lines[(midPoint+1):end])
end</code></pre>
<p>Of note, <code>connectColumns</code> walks through every index in <code>col1lines</code> (<code>eachindex(col1lines)</code>) and glues together the columns with the <code>string</code> function. The outcome of such string concatenation is put into <code>result[i]</code>. Splitting a long thin column in half may result in a columns of a slightly different lengths. Therefore, we cannot just use a regular indexing on <code>col2lines</code> (because if the element is not there we’ll get an error). Instead, we use the <code>get</code> function that we <a href="https://b-lukaszuk.github.io/RJ_BS_eng/julia_language_decision_making.html#sec:julia_language_dictionaries">encountered while working with dictionaries</a>. Likewise, here we also use a default value (<code>emptyColPad</code>) that gets returned if an element at a given index does not exist. It seems that we’re done with the chapter’s task. Go ahead, test the last function (<code>getDoubleColumn(lorem) |&gt; printLines</code>).</p>
<p>For a final challenge (a cherry on the top) add borders to the printout (or use the function <code>addBorder</code> from <a href="https://github.com/b-lukaszuk/BS_wJ_eng/tree/main/code_snippets/format_text">the code snippets</a>). This will allow to better visualize the correctness of your padding.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="./format_text_problem.html"><b>14.1</b> Problem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="./roman_numerals.html"><b>15</b> Roman numerals</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Bartlomiej Lukaszuk
</div>
</div>
</div>
</body>
</html>